---
title: 手动实现一个Promise
date: 2022-02-28 16:11:05
permalink: /pages/99b3e8/
categories:
  - 源码
tags:
  - Promise
  - Javascript
author: 
  name: 旗木五五开
  link: https://github.com/2513022260
---
# 手动实现一个Promise

基于`Promise/A+`实现一个`Promise`。
手写`Promise`需要考虑很多特殊情况。
我们在实际运用时可能暂时不会碰到这些情况，可是当我们遇到的时候 却不知底层的原理，无法精准定位和解决问题，这就是为什么我们要知道如何手写`Promise`。
<!-- more -->

包含知识点：
* Promise
* Class 类
* call、apply和bind
* Event Loop
* 发布、订阅

## 术语
* Promise：是一个拥有 then 方法的对象或函数，其行为符合本规范；
* thenable：是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”；
* 值（value）：指任何 JavaScript 的合法值（包括 undefined , thenable 和 promise）；
* 异常（exception）：是使用 throw 语句抛出的一个值。
* 据因（reason）：表示一个 promise 的拒绝原因。

## `Promise` 的状态
  * 等待态（Pending）
  * 执行态（Fulfilled）
  * 拒绝态（Rejected）
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
```

## `Promise.resolve()`和`Promise.reject()`
1. 原生的promise里面可以传入 `resolve` 和 `reject` 两个参数:
```js
const p = new Promise((resolve, reject) => {})
```
步骤：
* 新建`myPromise`类，添加构造函`constructor`的形参 `fn` 并执行。
* 增加原生方法`resolve` 和 `reject`。
* 将 `resolve` 和 `reject`传入fn。
```js
class myPromise {
  constructor(fn) {
    fn(this.resolve, this.reject)
  }
  resolve() {}
  reject() {}
}
```

2. 状态改变
定义一个`status`，用于表示状态，初始是`pending`
```js
class myPromise {
  constructor(fn) {
    this.status = PENDING
    fn(this.resolve, this.reject)
  }
  resolve() {}
  reject() {}
}
```
那么在执行`resolve()`的时候就需要判断状态是否为`待定pending`，如果是的话就把状态改为 `成功fulfilled`;
同理执行`reject()`的时候，如果判断状态是否为`待定pending`，就把状态改为 `拒绝rejected`。
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
class myPromise {
  constructor(fn) {
    this.status = PENDING
    fn(this.resolve, this.reject)
  }
  resolve() {
    if (this.status === PENDING) {
      this.status = FULFILLED
    }
  }
  reject() {
    if (this.status === PENDING) {
      this.status = REJECTED
    }
  }
}
```
resolve()接收一个成功值，reject()接收一个拒因。
```js
const p = new Promise((resolve, reject) => { resolve('成功') })
const p = new Promise((resolve, reject) => { reject('失败') })
```
我们将成功值与拒因分别存入实例的属性`value`和`reason`。
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
class myPromise {
  constructor(fn) {
    this.status = PENDING
    this.value = null
    this.reason = null
    fn(this.resolve, this.reject)
  }
  resolve(value) {
    if (this.status === PENDING) {
      this.status = FULFILLED
      this.value = value
    }
  }
  reject(reason) {
    if (this.status === PENDING) {
      this.status = REJECTED
      this.reason = reason
    }
  }
}
```
测试代码，发现报错，`this`丢失。
```js
const p = new myPromise((resolve, reject) => {
  resolve(2222222)
})

TypeError: Cannot read property 'status' of undefined
```
通过bind方法，给方法绑定this。
```js
fn(this.resolve.bind(this), this.reject.bind(this))
```


## `Promise.then()` 方法
  * 一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。
    promise 的 then 方法接受两个参数：
    ```js
    promise.then(onFulfilled, onRejected)
    ```
  * then 方法必须返回一个 promise 对象
## 实现异步
## `Promise.then()` 的链式调用
## 实现 `resolvePromise` 方法

## 链接
* [Promises/A+](https://promisesaplus.com/)
* [【翻译】Promises/A+规范](https://www.ituring.com.cn/article/66566)
